// Wed Jan 15 2026 - Alex

use super::types::{FFlag, FFlagType, FFlagValue, FFlagCollection, FFlagStats};
use serde::{Deserialize, Serialize};
use std::fs::File;
use std::io::{Write, BufWriter};
use std::path::Path;
use std::collections::HashMap;

pub struct FFlagDumper {
    include_addresses: bool,
    include_values: bool,
    group_by_type: bool,
    sort_alphabetically: bool,
}

impl FFlagDumper {
    pub fn new() -> Self {
        Self {
            include_addresses: true,
            include_values: true,
            group_by_type: true,
            sort_alphabetically: true,
        }
    }

    pub fn with_addresses(mut self, include: bool) -> Self {
        self.include_addresses = include;
        self
    }

    pub fn with_values(mut self, include: bool) -> Self {
        self.include_values = include;
        self
    }

    pub fn grouped(mut self, group: bool) -> Self {
        self.group_by_type = group;
        self
    }

    pub fn sorted(mut self, sort: bool) -> Self {
        self.sort_alphabetically = sort;
        self
    }

    pub fn dump_to_json<P: AsRef<Path>>(&self, collection: &FFlagCollection, path: P) -> std::io::Result<()> {
        let output = FFlagJsonOutput::from_collection(collection, self.include_addresses, self.include_values);
        let json = serde_json::to_string_pretty(&output)?;

        let file = File::create(path)?;
        let mut writer = BufWriter::new(file);
        writer.write_all(json.as_bytes())?;

        Ok(())
    }

    pub fn dump_to_text<P: AsRef<Path>>(&self, collection: &FFlagCollection, path: P) -> std::io::Result<()> {
        let file = File::create(path)?;
        let mut writer = BufWriter::new(file);

        writeln!(writer, "FFlag Dump - {} total flags", collection.total_count)?;
        writeln!(writer, "==========================================")?;
        writeln!(writer)?;

        self.write_stats(&mut writer, &collection.by_type)?;
        writeln!(writer)?;

        if self.group_by_type {
            self.write_grouped(&mut writer, collection)?;
        } else {
            self.write_flat(&mut writer, collection)?;
        }

        Ok(())
    }

    pub fn dump_to_csv<P: AsRef<Path>>(&self, collection: &FFlagCollection, path: P) -> std::io::Result<()> {
        let file = File::create(path)?;
        let mut writer = BufWriter::new(file);

        writeln!(writer, "Type,Name,Value,Address")?;

        let mut flags: Vec<&FFlag> = collection.flags.iter().collect();
        if self.sort_alphabetically {
            flags.sort_by(|a, b| a.name.cmp(&b.name));
        }

        for flag in flags {
            let value_str = if self.include_values {
                format!("{}", flag.value)
            } else {
                String::new()
            };

            let addr_str = if self.include_addresses {
                format!("0x{:X}", flag.address)
            } else {
                String::new()
            };

            writeln!(writer, "{},{},{},{}", flag.flag_type, flag.name, value_str, addr_str)?;
        }

        Ok(())
    }

    pub fn dump_names_only<P: AsRef<Path>>(&self, collection: &FFlagCollection, path: P) -> std::io::Result<()> {
        let file = File::create(path)?;
        let mut writer = BufWriter::new(file);

        let mut flags: Vec<&FFlag> = collection.flags.iter().collect();
        if self.sort_alphabetically {
            flags.sort_by(|a, b| a.name.cmp(&b.name));
        }

        for flag in flags {
            writeln!(writer, "{}{}", flag.prefix(), flag.name)?;
        }

        Ok(())
    }

    pub fn dump_lua_table<P: AsRef<Path>>(&self, collection: &FFlagCollection, path: P) -> std::io::Result<()> {
        let file = File::create(path)?;
        let mut writer = BufWriter::new(file);

        writeln!(writer, "-- FFlag dump generated by roblox-offset-generator")?;
        writeln!(writer, "-- Total flags: {}", collection.total_count)?;
        writeln!(writer)?;
        writeln!(writer, "local FFlags = {{")?;

        let mut flags: Vec<&FFlag> = collection.flags.iter().collect();
        if self.sort_alphabetically {
            flags.sort_by(|a, b| a.name.cmp(&b.name));
        }

        for flag in flags {
            let value_str = match &flag.value {
                FFlagValue::Bool(b) => format!("{}", b),
                FFlagValue::Int(i) => format!("{}", i),
                FFlagValue::String(s) => format!("\"{}\"", s.replace("\"", "\\\"")),
                FFlagValue::Log(l) => format!("{}", l),
                FFlagValue::Unknown => "nil".to_string(),
            };

            writeln!(writer, "    [\"{}{}\"] = {},", flag.prefix(), flag.name, value_str)?;
        }

        writeln!(writer, "}}")?;
        writeln!(writer)?;
        writeln!(writer, "return FFlags")?;

        Ok(())
    }

    fn write_stats<W: Write>(&self, writer: &mut W, stats: &FFlagStats) -> std::io::Result<()> {
        writeln!(writer, "Statistics:")?;
        writeln!(writer, "  Fast Flags (FFlag):    {}", stats.fflags)?;
        writeln!(writer, "  Fast Ints (FInt):      {}", stats.fints)?;
        writeln!(writer, "  Fast Strings (FString):{}", stats.fstrings)?;
        writeln!(writer, "  Fast Logs (FLog):      {}", stats.flogs)?;
        writeln!(writer, "  Dynamic Flags (DFFlag):{}", stats.dfflags)?;
        writeln!(writer, "  Dynamic Ints (DFInt):  {}", stats.dfints)?;
        writeln!(writer, "  Dynamic Strings:       {}", stats.dfstrings)?;
        writeln!(writer, "  Dynamic Logs:          {}", stats.dflogs)?;
        writeln!(writer, "  Sync Flags (SFFlag):   {}", stats.sfflags)?;
        writeln!(writer, "  Sync Ints (SFInt):     {}", stats.sfints)?;
        writeln!(writer, "  Sync Strings:          {}", stats.sfstrings)?;
        writeln!(writer, "  Sync Logs:             {}", stats.sflogs)?;
        writeln!(writer, "  Unknown:               {}", stats.unknown)?;
        writeln!(writer, "  -------------------------")?;
        writeln!(writer, "  Total:                 {}", stats.total())?;
        Ok(())
    }

    fn write_grouped<W: Write>(&self, writer: &mut W, collection: &FFlagCollection) -> std::io::Result<()> {
        let type_order = [
            FFlagType::FFlag, FFlagType::FInt, FFlagType::FString, FFlagType::FLog,
            FFlagType::DFFlag, FFlagType::DFInt, FFlagType::DFString, FFlagType::DFLog,
            FFlagType::SFFlag, FFlagType::SFInt, FFlagType::SFString, FFlagType::SFLog,
        ];

        for flag_type in &type_order {
            let mut flags: Vec<&FFlag> = collection.flags.iter()
                .filter(|f| &f.flag_type == flag_type)
                .collect();

            if flags.is_empty() {
                continue;
            }

            if self.sort_alphabetically {
                flags.sort_by(|a, b| a.name.cmp(&b.name));
            }

            writeln!(writer, "[{}] ({} flags)", flag_type, flags.len())?;
            writeln!(writer, "----------------------------")?;

            for flag in flags {
                self.write_flag(writer, flag)?;
            }

            writeln!(writer)?;
        }

        Ok(())
    }

    fn write_flat<W: Write>(&self, writer: &mut W, collection: &FFlagCollection) -> std::io::Result<()> {
        let mut flags: Vec<&FFlag> = collection.flags.iter().collect();

        if self.sort_alphabetically {
            flags.sort_by(|a, b| {
                let a_full = format!("{}{}", a.prefix(), a.name);
                let b_full = format!("{}{}", b.prefix(), b.name);
                a_full.cmp(&b_full)
            });
        }

        for flag in flags {
            self.write_flag(writer, flag)?;
        }

        Ok(())
    }

    fn write_flag<W: Write>(&self, writer: &mut W, flag: &FFlag) -> std::io::Result<()> {
        let mut line = format!("{}{}", flag.prefix(), flag.name);

        if self.include_values {
            line.push_str(&format!(" = {}", flag.value));
        }

        if self.include_addresses {
            line.push_str(&format!(" @ 0x{:X}", flag.address));
        }

        writeln!(writer, "{}", line)
    }

    pub fn to_string(&self, collection: &FFlagCollection) -> String {
        let mut output = String::new();

        output.push_str(&format!("FFlag Dump - {} total flags\n", collection.total_count));
        output.push_str("==========================================\n\n");

        let mut flags: Vec<&FFlag> = collection.flags.iter().collect();
        if self.sort_alphabetically {
            flags.sort_by(|a, b| a.name.cmp(&b.name));
        }

        for flag in flags {
            output.push_str(&format!("{}\n", flag));
        }

        output
    }
}

impl Default for FFlagDumper {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FFlagJsonOutput {
    pub version: String,
    pub total_count: usize,
    pub stats: FFlagStats,
    pub flags: HashMap<String, FFlagJsonEntry>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct FFlagJsonEntry {
    pub flag_type: String,
    pub value: serde_json::Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub address: Option<String>,
}

impl FFlagJsonOutput {
    pub fn from_collection(collection: &FFlagCollection, include_addresses: bool, include_values: bool) -> Self {
        let mut flags = HashMap::new();

        for flag in &collection.flags {
            let value = if include_values {
                match &flag.value {
                    FFlagValue::Bool(b) => serde_json::Value::Bool(*b),
                    FFlagValue::Int(i) => serde_json::Value::Number((*i).into()),
                    FFlagValue::String(s) => serde_json::Value::String(s.clone()),
                    FFlagValue::Log(l) => serde_json::Value::Number((*l).into()),
                    FFlagValue::Unknown => serde_json::Value::Null,
                }
            } else {
                serde_json::Value::Null
            };

            let address = if include_addresses {
                Some(format!("0x{:X}", flag.address))
            } else {
                None
            };

            let entry = FFlagJsonEntry {
                flag_type: flag.flag_type.to_string(),
                value,
                address,
            };

            flags.insert(format!("{}{}", flag.prefix(), flag.name), entry);
        }

        Self {
            version: "1.0.0".to_string(),
            total_count: collection.total_count,
            stats: collection.by_type.clone(),
            flags,
        }
    }
}
